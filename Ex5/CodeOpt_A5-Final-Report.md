# Code Optimization: Assignment N°5 Report

###### Duy Le - Cédric Léonard, 6/12/2021

### Introduction
The assignment is about understanding the complier-generated assembly language

### Question N°1

a. Compile the code with optimization level -O2 and generate assembly language code for the saxpy procedure:

The assembly code are generated by the following command:
    ```gcc -c -g -O2 saxpy.c -std=c99```
    ```objdump -d -S saxpy.o```

Here are the assembly code generated:

```assembly
0000000000000000 <saxpy>:
/*
  Single-precision A*X plus Y, Y = alpha*X+Y
*/

void saxpy(int n, float alpha, float *X, float *Y) {
  for (int i=0; i<n; i++)
   0:   31 c0                   xor    %eax,%eax
   2:   85 ff                   test   %edi,%edi
   4:   7e 25                   jle    2b <saxpy+0x2b>
   6:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
   d:   00 00 00
    Y[i] = alpha*X[i] + Y[i];
  10:   f3 0f 10 0c 86          movss  (%rsi,%rax,4),%xmm1
  15:   f3 0f 59 c8             mulss  %xmm0,%xmm1
  19:   f3 0f 58 0c 82          addss  (%rdx,%rax,4),%xmm1
  1e:   f3 0f 11 0c 82          movss  %xmm1,(%rdx,%rax,4)
  23:   48 83 c0 01             add    $0x1,%rax
  for (int i=0; i<n; i++)
  27:   39 c7                   cmp    %eax,%edi
  29:   7f e5                   jg     10 <saxpy+0x10>
  2b:   f3 c3                   repz retq
```

- How are the parameters passed to the procedure
The parameters are passed to the procedure through RDI, RSI, RDX, RCX
- How is the loop implemented?

- How are the arithmetic operations done?
- Instructions that have no effect, i.e. that are inserted by the compiler to align branch targets?


b. Compile the saxpy procedure with full optimizations (-O3) and look at the generated assembly language code.

The assembly code are generated by the following command:
     ```gcc -c -g saxpy.c -o saxpyo3.o -O3 --std=c99```
    ```objdump -d -S saxpyo3.o```

Here are the assembly code generated:

```assembly
saxpyo3.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <saxpy>:
/*
  Single-precision A*X plus Y, Y = alpha*X+Y
*/

void saxpy(int n, float alpha, float *X, float *Y) {
  for (int i=0; i<n; i++)
   0:   85 ff                   test   %edi,%edi
   2:   0f 8e fb 00 00 00       jle    103 <saxpy+0x103>
   8:   48 8d 42 10             lea    0x10(%rdx),%rax
   c:   48 39 c6                cmp    %rax,%rsi
   f:   48 8d 46 10             lea    0x10(%rsi),%rax
  13:   0f 93 c1                setae  %cl
  16:   48 39 c2                cmp    %rax,%rdx
  19:   0f 93 c0                setae  %al
  1c:   08 c1                   or     %al,%cl
  1e:   0f 84 bc 00 00 00       je     e0 <saxpy+0xe0>
  24:   83 ff 05                cmp    $0x5,%edi
  27:   0f 86 b3 00 00 00       jbe    e0 <saxpy+0xe0>
  2d:   0f 28 e0                movaps %xmm0,%xmm4
  30:   41 89 f9                mov    %edi,%r9d
  33:   31 c0                   xor    %eax,%eax
  35:   41 c1 e9 02             shr    $0x2,%r9d
    Y[i] = alpha*X[i] + Y[i];
  39:   0f 57 db                xorps  %xmm3,%xmm3
  3c:   0f c6 e4 00             shufps $0x0,%xmm4,%xmm4
  40:   46 8d 04 8d 00 00 00    lea    0x0(,%r9,4),%r8d
  47:   00
  for (int i=0; i<n; i++)
  48:   31 c9                   xor    %ecx,%ecx
    Y[i] = alpha*X[i] + Y[i];
  4a:   0f 28 cb                movaps %xmm3,%xmm1
  4d:   0f 28 d3                movaps %xmm3,%xmm2
  50:   83 c1 01                add    $0x1,%ecx
  53:   0f 12 0c 06             movlps (%rsi,%rax,1),%xmm1
  57:   0f 12 14 02             movlps (%rdx,%rax,1),%xmm2
  5b:   0f 16 4c 06 08          movhps 0x8(%rsi,%rax,1),%xmm1
  60:   0f 16 54 02 08          movhps 0x8(%rdx,%rax,1),%xmm2
  65:   0f 59 cc                mulps  %xmm4,%xmm1
  68:   0f 58 ca                addps  %xmm2,%xmm1
  6b:   0f 13 0c 02             movlps %xmm1,(%rdx,%rax,1)
  6f:   0f 17 4c 02 08          movhps %xmm1,0x8(%rdx,%rax,1)
  74:   48 83 c0 10             add    $0x10,%rax
  78:   44 39 c9                cmp    %r9d,%ecx
  7b:   72 cd                   jb     4a <saxpy+0x4a>
  7d:   44 39 c7                cmp    %r8d,%edi
  80:   0f 84 7d 00 00 00       je     103 <saxpy+0x103>
  86:   49 63 c8                movslq %r8d,%rcx
  89:   f3 0f 10 0c 8e          movss  (%rsi,%rcx,4),%xmm1
  8e:   48 8d 04 8a             lea    (%rdx,%rcx,4),%rax
  for (int i=0; i<n; i++)
  92:   41 8d 48 01             lea    0x1(%r8),%ecx
    Y[i] = alpha*X[i] + Y[i];
  96:   f3 0f 59 c8             mulss  %xmm0,%xmm1
  for (int i=0; i<n; i++)
  9a:   39 cf                   cmp    %ecx,%edi
    Y[i] = alpha*X[i] + Y[i];
  9c:   f3 0f 58 08             addss  (%rax),%xmm1
  a0:   f3 0f 11 08             movss  %xmm1,(%rax)
  for (int i=0; i<n; i++)
  a4:   7e 5d                   jle    103 <saxpy+0x103>
    Y[i] = alpha*X[i] + Y[i];
  a6:   48 63 c9                movslq %ecx,%rcx
  for (int i=0; i<n; i++)
  a9:   41 83 c0 02             add    $0x2,%r8d
    Y[i] = alpha*X[i] + Y[i];
  ad:   f3 0f 10 0c 8e          movss  (%rsi,%rcx,4),%xmm1
  b2:   48 8d 04 8a             lea    (%rdx,%rcx,4),%rax
  for (int i=0; i<n; i++)
  b6:   44 39 c7                cmp    %r8d,%edi
    Y[i] = alpha*X[i] + Y[i];
  b9:   f3 0f 59 c8             mulss  %xmm0,%xmm1
  bd:   f3 0f 58 08             addss  (%rax),%xmm1
  c1:   f3 0f 11 08             movss  %xmm1,(%rax)
  for (int i=0; i<n; i++)
  c5:   7e 41                   jle    108 <saxpy+0x108>
    Y[i] = alpha*X[i] + Y[i];
  c7:   4d 63 c0                movslq %r8d,%r8
  ca:   f3 42 0f 59 04 86       mulss  (%rsi,%r8,4),%xmm0
  d0:   4a 8d 04 82             lea    (%rdx,%r8,4),%rax
  d4:   f3 0f 58 00             addss  (%rax),%xmm0
  d8:   f3 0f 11 00             movss  %xmm0,(%rax)
  dc:   c3                      retq
  dd:   0f 1f 00                nopl   (%rax)
  for (int i=0; i<n; i++)
  e0:   31 c0                   xor    %eax,%eax
  e2:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    Y[i] = alpha*X[i] + Y[i];
  e8:   f3 0f 10 0c 86          movss  (%rsi,%rax,4),%xmm1
  ed:   f3 0f 59 c8             mulss  %xmm0,%xmm1
  f1:   f3 0f 58 0c 82          addss  (%rdx,%rax,4),%xmm1
  f6:   f3 0f 11 0c 82          movss  %xmm1,(%rdx,%rax,4)
  fb:   48 83 c0 01             add    $0x1,%rax
  for (int i=0; i<n; i++)
  ff:   39 c7                   cmp    %eax,%edi
 101:   7f e5                   jg     e8 <saxpy+0xe8>
 103:   f3 c3                   repz retq
 105:   0f 1f 00                nopl   (%rax)
 108:   f3 c3                   repz retq
 ```

c. Complile the saxpy procedure with -O2 optimization and the addtional flag -mfpmath=387

The assembly code are generated by the following command:
     ```gcc -c -g saxpy.c -o saxpyo2mfpm.o -O2 -mfpmath=387 --std=c99```
    ```objdump -d -S saxpyo2mfpm.o```

Here are the assembly code generated:

```assembly
saxpyo2mfpm.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <saxpy>:
/*
  Single-precision A*X plus Y, Y = alpha*X+Y
*/

void saxpy(int n, float alpha, float *X, float *Y) {
  for (int i=0; i<n; i++)
   0:   85 ff                   test   %edi,%edi
   2:   7e 21                   jle    25 <saxpy+0x25>
   4:   f3 0f 11 44 24 f0       movss  %xmm0,-0x10(%rsp)
   a:   31 c0                   xor    %eax,%eax
   c:   d9 44 24 f0             flds   -0x10(%rsp)
    Y[i] = alpha*X[i] + Y[i];
  10:   d9 c0                   fld    %st(0)
  12:   d8 0c 86                fmuls  (%rsi,%rax,4)
  15:   d8 04 82                fadds  (%rdx,%rax,4)
  18:   d9 1c 82                fstps  (%rdx,%rax,4)
  1b:   48 83 c0 01             add    $0x1,%rax
  for (int i=0; i<n; i++)
  1f:   39 c7                   cmp    %eax,%edi
  21:   7f ed                   jg     10 <saxpy+0x10>
  23:   dd d8                   fstp   %st(0)
  25:   f3 c3                   repz retq
  ```

### Question N°2
Compile the function med3 with optimization level -O2 and generate assembly code for it. Analyze and explain the assembly code like in question 1a

The assembly code are generated by the following command:
     ```gcc -c -g med3.c -o med3o2.o -O2 --std=c99```
    ```objdump -d -S med3o2.o```

Here are the assembly code generated:

```assembly
med3o2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <med3>:

int med3(int a, int b, int c) {
  int mid;
  if ( a > b )   {
   0:   39 f7                   cmp    %esi,%edi
int med3(int a, int b, int c) {
   2:   89 f0                   mov    %esi,%eax
  if ( a > b )   {
   4:   7e 12                   jle    18 <med3+0x18>
    if ( c > b) {
   6:   39 d6                   cmp    %edx,%esi
   8:   7d 19                   jge    23 <med3+0x23>
   a:   39 d7                   cmp    %edx,%edi
   c:   89 d0                   mov    %edx,%eax
   e:   0f 4e c7                cmovle %edi,%eax
  11:   c3                      retq
  12:   66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    else {
      mid = b;
    }
  }
  else {
    if ( b > c ) {
  18:   39 d6                   cmp    %edx,%esi
  1a:   7e 07                   jle    23 <med3+0x23>
  1c:   39 d7                   cmp    %edx,%edi
  1e:   89 d0                   mov    %edx,%eax
  20:   0f 4d c7                cmovge %edi,%eax
    else {
      mid = b;
    }
  }
  return mid ;
}
  23:   f3 c3                   repz retq
```

### Question N°3
The procedure in the attached file call_max.c illustrates how procedure calls are implemented in the generated assembly language

a.
The assembly code are generated by the following command:
     ```gcc -c -g call_max.c -o call_max-fno-inline.o -O2 --std=c99```
    ```objdump -d -S call_max-fno-inline.o```

Here are the assembly code generated:

```assembly
call_max-fno-inline.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <max>:
int max(int a, int b) {
   0:   39 f7                   cmp    %esi,%edi
   2:   89 f0                   mov    %esi,%eax
   4:   0f 4d c7                cmovge %edi,%eax
  if (a>b) return a;
  else return b;
}
   7:   c3                      retq
   8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
   f:   00

0000000000000010 <select>:

void select (int *a, int *b, int len) {

  for (int i=0; i<len; i++) {
  10:   31 c0                   xor    %eax,%eax
  12:   85 d2                   test   %edx,%edx
  14:   7e 1f                   jle    35 <select+0x25>
  16:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  1d:   00 00 00
  20:   8b 0c 86                mov    (%rsi,%rax,4),%ecx
  23:   39 0c 87                cmp    %ecx,(%rdi,%rax,4)
  26:   0f 4d 0c 87             cmovge (%rdi,%rax,4),%ecx
    a[i] = max(a[i], b[i]);
  2a:   89 0c 87                mov    %ecx,(%rdi,%rax,4)
  2d:   48 83 c0 01             add    $0x1,%rax
  for (int i=0; i<len; i++) {
  31:   39 c2                   cmp    %eax,%edx
  33:   7f eb                   jg     20 <select+0x10>
  35:   f3 c3                   repz retq
  ```


b.
The assembly code are generated by the following command:
     ```gcc -c -g call_max.c -o call_max.o -O2 --std=c99```
    ```objdump -d -S call_max.o```

Here are the assembly code generated:

```assembly
call_max-.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <max>:
int max(int a, int b) {
   0:   39 f7                   cmp    %esi,%edi
   2:   89 f0                   mov    %esi,%eax
   4:   0f 4d c7                cmovge %edi,%eax
  if (a>b) return a;
  else return b;
}
   7:   c3                      retq
   8:   0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
   f:   00

0000000000000010 <select>:

void select (int *a, int *b, int len) {

  for (int i=0; i<len; i++) {
  10:   31 c0                   xor    %eax,%eax
  12:   85 d2                   test   %edx,%edx
  14:   7e 1f                   jle    35 <select+0x25>
  16:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  1d:   00 00 00
  20:   8b 0c 86                mov    (%rsi,%rax,4),%ecx
  23:   39 0c 87                cmp    %ecx,(%rdi,%rax,4)
  26:   0f 4d 0c 87             cmovge (%rdi,%rax,4),%ecx
    a[i] = max(a[i], b[i]);
  2a:   89 0c 87                mov    %ecx,(%rdi,%rax,4)
  2d:   48 83 c0 01             add    $0x1,%rax
  for (int i=0; i<len; i++) {
  31:   39 c2                   cmp    %eax,%edx
  33:   7f eb                   jg     20 <select+0x10>
  35:   f3 c3                   repz retq
```
